## 소프트웨어 개발 보안 설계



**소프트웨어 개발 보안**

1. 도출(Elicitation)
2. 분석(Analysis)
3. 명세(Specification)
4. 확인(Vaildation)



**SDLC 보안 적용 사례**

- MS-SDL 
  - 마이크로소프트사에서 자체적으로 수립한 SDL 방법론
- Seven Touch Points
  - 소프트웨어 보안 모범 사례를 SDL에 통합
  - 공통 위험 요소 파악하고 이해
- CLASP
  - SDLC 초기 단계 보안 강화 목적
  - 정형화된 개발 보안 프로세스



**정보 보안 3대 요소**

- 기밀성(Confidentially)
- 무결성(Integrity) - 인가된 사용자가 인가된 방법으로만 수정
- 가용성(Availability)



**KISA** - 한국인터넷진흥원 / 개발 보안 정책 및 가이드 개발



## 암호화 알고리즘



**시큐어 코딩 가이드** 

- 7항목 - 입력 데이터 검증 및 표현 / 보안 기능 / 시간 및 상태 / 에러 처리 / 코드 오류 / 캡슐화 / API 오용



**암호화 알고리즘**

- 양방향
  - 대칭키(비밀키) - 키 분배가 공개키보다 어려움
    - 스트림 방식
      - 암호화 할 때 XOR 연산 사용
      - RC4 / SEAL ...
    - 블록 방식
      - 평문을 블록 단위로 암호화
      - DES -  IBM이 개발 / 전사공격에 취약
      - AES - DES 대신하는 표준 / SPN 구조
      - ARIA - 우리나라 개발 / 우리나라 표준
      - SEED - 국내 개발 / 국제 표준으로 지정
      - IDEA - 스위스에서 DES 대체하기 위해 개발 / 세 가지 연산 혼합
  - 비대칭키(공개키)
    - 복호화키 공개해도 ㅇ
    - RSA - 소인수분해 어려움 기초 / MIT에 의해 제안
    - EIGama - 이산대수 문제 기초 / 암호문의 길이가 2배로 늘어나는 특징
- 해시(HASH)
  - 고정된 길이의 출력값으로 변환
  - 의사 난수 생성 > 값 > 해시값
  - 디지털 서명에 이용 > 데이터 무결성 제공
  - SHA - 미국 NIST에 의해 개발 / 가장 많이 사용
  - MD5 - 충돌 회피성에서 문제점 발견
  - HAS-160 - 국내에서 개발 / SHA와 비슷



## 서비스 공격 유형



- DoS - 시스템 자원 부족하게 해서 원래 용도로 사용하지 못하게
  - 가용성 위협
  - 자신의 IP 주소를 속여서 다량으로 서버에 보냄
  - 스머프(Smurf) - 대량의 ICMP 응답 패킷 전송 > 서비스 거부 유발
  - TCP SYN flooding - TCP 연결 설정 과정의 취약점 악용
  - UDP 플러딩 - 대량의 UDP 패킷 만들어 보내서 정상적 서비스 못하게
  - Ping 플러딩 - Ping 테스트를 공격 대상 컴퓨터를 확인하려는 방법으로 사용
  - Ping of Death - 비정상적 ICMP 패킷 전송 > 성능 저하
  - 티어드랍 - 패킷 재조합 문제 악용 > 순서 조작된 조각들 보내서 자원 고갈
  - LAND Attack - IP 스푸핑 이용한 SYN 공격 / 출발지랑 목적지 주소 동일하게
- DDoS - 여러 대 공격자 분산 배치 > 동시에 서비스 거부 공격
  - 공격에 사용된 좀비 PC는 스스로 하드디스크 손상시킬 수 ㅇ
  - 좀비 PC끼리 형성된 네트워크 >> 봇넷
  - 공격용 도구 : Trinoo, TFN 등 
- 피싱 - 가짜 웹사이트를 통해서 개인정보 탈취
- 파밍 - DNS의 이름을 속여서 진짜 웹사이트로 오인하게
- 스니핑 - 도청(자기가 아닌 다른 사람들의 패킷 교환을 엿듣기)
- 스미싱 - 메시지를 통해 주소 클릭하면 악성코드 설치
- 큐싱 - QR코드를 통해 악성 앱 내려받도록
- 랜섬웨어
- 키로거
- SQL 삽입 - 악의적으로 만든 SQL 명령을 수행하도록
- XSS - 원본과 함께 악성코드 삽입 > 읽으면 실행
- 무작위 대입 공격 - 문자열 범위 정하고 생성 가능한 패스워드 활용
- 스피어 피싱 - 합법적 웹 사이트 미리 감염 > 방문하면 악성코드 설치
- APT - 장기간 접근을 위해 지속해서 수행되는 공격(지능적 지속 위협)
- 제로데이 - 알려지지 않은 취약점 및 악성 코드 등을 감염
- 백도어 - tripwire : 백도어 만들어 놓거나 파일 변경했을 때 분석하는 도구
- Rainbow Table Attack - 패스워드별로 해시값 미리 생성 > 반복 수행 > 일치하는 해시값으로 패스워드 탈취
- CSRF - 불특정 다수 대상으로 의지와 상관없이 의도에 따라 행동하게 만드는
- TOCTOU - 병렬 시스템 사용할 때 두 지점 사이 타이밍 노림



## 서버 인증



**사용자 인증 기법**

- 지식 기반 인증 - 아이디, 패스워드 같은
- 소유 기반 인증 - 인증 토큰 기반 / OTP, 스마트 카드 등
- 생체 기반 인증 



**서버 접근 통제** - 비인가자가 액세스하지 못하도록

- 접근 통제 요소 - 식별 / 인증 / 인가

- 강제적 접근 통제(MAC) - 중앙에서 보안 레벨 결정
  - 중앙 집중적 접근 통제 가능
  - 기밀성 매우 중요한 조직에서 사용
  - 다단계 보안 모델
  - Biba / Bell-Lapadula
- 임의적 접근 통제(DAC) - 정보 소유자가 보안 레벨 결정
  - 유연한 접근제어 서비스
- 역할 기반 접근 통제(RBAC) - 직책에 대한 권한 부여



## 보안 아키텍쳐



**보안 아키텍쳐** - 기밀성, 무결성, 가용성 높이기 위한

- 보안 프레임워크 - 기술적 보안, 관리적 보안, 물리적 보안 프레임워크로 나눠짐



**ISO 27001** - ISMS 요구사항 / 정보보호 관리체계에 대해 국제 인증 시 요구사항 정의



## 보안 솔루션



**방화벽** 

- 내부 네트워크와 외부 네트워크 사이에 위치
- 내부에서 외부로 나가는 패킷은 그대로 통과 > 방어하기 어려움
- 패킷 필터링 - 출발지, 목적지 IP 주소, 포트 번호 등 이용한 접속 제어 / OSI 3, 4계층에서 처리 > 속도 빠름
- 상태 검사 - 현재 연결 세션의 트래픽 상태와, 미리 저장된 상태와의 비교
- 응용 레벨 게이트웨이 - OSI 참조 모델 7계층  감시 > 안전한 데이터만 릴레이 > 속도 느림
- 회선 레벨 게이트웨이 - 두 개의 TCP 연결 설정 / 내부 IP 주소를 숨길 수 있음



**웹 방화벽**

- 클라이언트가 보낸 요청 검사 > 차단
- 사용자에게 실제 서버의 위치와 서버 정보를 숨기는 기능



**IDS 침입 탐지 시스템** - 외부 침입 탐지 목표 / 사후 조치 

- IDS 분류
  - HIDS - host based / 호스트 자원 일정 부분 점유
  - NIDS - network based / HIDS에 탐지하지 못한 침입 탐지
- 침입 탐지 기법
  - 오용 탐지 - 이미 발견돼서 알려진 공격 패턴과 일치하는지 
  - 이상 탐지 - 장기간 수집된 사용자 행동 패턴 / 알려지지 않은 공격에 굿



**IPS 침입 방지 시스템** - IDS와 방화벽 장점 결합 / 사전 조치

**DMZ 비무장 지대** - 보안 조치가 취해진 영역 / 웹서버, DNS서버, 메일 서버 등

**NAC 네트워크 접근 제어** - 접근하기 전에 보안 정책 준수 여부 검사해서 접근 통제

**DLP** - 기업 데이터 유출 방지 목표

**ESM 통합 보안 관리** - 보안 솔루션 하나로 모은 통합 보안 관리 시스템 / 각종 로그 통합 관리

**VPN 가상 사설망** - 안전하지 않은 공용 네트워크를 이용해서 사설 네트워크 구성 / 기밀성과 무결성 제공



## 취약점 분석 및 평가



**취약점 분석 기본 항목** 

- 기본 항목은 관리적, 물리적, 기술적 분야로 구분
- 상, 중, 하로 중요도 분리
  - 상은 필수로 점검
  - 중, 하는 기관의 사정에 따라 선택적으로 점검
- 절차
  1. 계획 수립
  2. 대상 선별
  3. 취약점 분석
  4. 취약점 수행



**로그 분석** 

- 데이터에 대한 기록이 파일, 인쇄물 형태로 저장
- 내부에서 영향 미치거나, 외부에서 시스템에 영향 미칠 때 > 데이터 기록해서 문제 해결이나 예방
- 로그 관리
  - 인증 Authentication - 사용자 신원 검증 제공
  - 인가 Authorization - 사용자에게 허용할 권한 제공
  - 계정 Accounting - 자원에 대한 정보 취합해서 제공
  - 로그는 중앙 시스템에 기록하거나, 분산 기록



---



## C

```c
#include <stdio.h>
int main()
{
	int month, day, birthday;
    int x, y;
    x = 5;
    y = 2;
    month = 1;
    day = 10;
    birthday = month == 8 && day == 19;
    print('birthday : %d', birthday);  //birthday : 0
    print('5>2 : %d', x>y);  //1
	return 0;
}
```

```c
#include <stdio.h>
int main()
{
    int Age;
    Age = 20;
    print('age : %d', Age); //20
    scanf('%d', &Age); 
    print('age : %d', Age); //25
    return 0;
}
```

```c
#include <stdio.h>
int main()
{
    int x, y, big;
    x = 5;
    y = 2;
    big = (x>y) ? x : y;
    print('큰 값 : %d\n', big); // 큰값 : 5
    return 0;
}
```

```c
#include <stdio.h>
int main()
{
    int i;
    int sum = 0;
    i = 1;
    do
    {
        sum += i;
        i++;
    }
    while(i <= 10);
    print('1~10 sum : %d', sum);
    return 0;
}
```

```c
#include <stdio.h>
int main()
{
    int i, j, sub_total;
    int s[3][2] = {{10,20},{30,40},{50,60}};
    for(i = 0; i < 3; i++){
        sub_total = 0;
        for(j = 0; j < 2; j++){
            sub_total += s[i][j];
        }
        print('%d 총점 : %d\n', i+1, sub_total);
    }
    return 0;
}
```



**비트 연산자**

- \>> << 시프트 연산자
  - \<< 왼쪽으로 이동
  - \<< 오른쪽으로 이동
- 논리 연산자
  - & : 논리곱(AND)
  - ^ : 배타적 논리합(XOR)
  - | : 논리합(OR)
  - ~ : 논리부정(NOT)



**연산자 우선순위**

1. 단항 연산자

   1. () [] - > .

   2. ! ~ ++ -- & * sizeof() cast

2. 이항 연산자

   1. \* / %
   2. \+ -
   3. << >>
   4. \> \>= \< \<=
   5. == != 
   6. &
   7. ^
   8. |
   9. &&
   10. ||

3. 삼항 연산자

   1. ? :

4. 대입 연산자

   1. = += *= &= 

5. 나열 연산자

   1. ,

## JAVA

```java
public class ArrayEx 
{
    public static void main(String[] args)
    {
        int[ ] intArr = {1, 2, 3};
        //int []intArr = {1,2,3};
        //int[] intArr = new int[3];
        for(int i = 0; i < intArr.length; i++)
            intArr[i] = i + 1;
        for(int i : intArr)
        {
            System.out.print(i + '');
        }
        System.out.println();
    }
} 
//1 2 3
```

```java
public class ArrayEx
{
    public static void main(String[] args)
    {
        String str1 = 'Semantic';
        String str2 = 'Error';
        String str3 = str1 + str2;
        System.out.println(str3); //SemanticError
    }
}
```

```java
public class ArrayEx
{
    public static void main(String[] args)
    {
        Scanner input = new Scanner(System.in);
        System.out.print('+ - choose : ');
        String sel = input.next();
        if(sel.equals('1'))
            System.out.println('10 + 20 = ' + (10+20));
        if(sel.equals('2'))
            System.out.println('10 - 20 = ' + (10-20));
    }
}
```



**연산자 우선순위**

1. 단항 연산자
   1. () []
   2. ! ~ ++ -- cast new
2. 이항 연산자
   1. \* / %
   2. \+ -
   3. \<< >> >>>
   4. \> \>= \< \<= instanceof
   5. == != 
   6. &
   7. ^
   8. |
   9. &&
   10. ||
3. 삼항 연산자
   1. ? :
4. 대입 연산자
   1. = += *= &=
5. 나열 연산자
   1. ,



**tree** - 포인터 변수 사용할 때 기억장소의 관리 문제로, 데이터 접근 경로가 없어진 후에도 메모리에 지속적으로 남아있어서(garbage), 이 쓰레기를 없애기 위해 사용되는 함수명



```c
#include <stdio.h>
int main()
{
    int num = 98;
    int *ptr;
    ptr = &num;
    num = num + 1;
    printf('%d/n', num);
    *ptr = *ptr + 1;
    print('%d', *ptr);
    return 0;
}
```

```c
#include <stdio.h>
struct student{
    char name[20];
    int kor, math, sum, total;
}
int main(){
    struct student s[3] = {{'a', 90, 85}, {'b', 100, 91}, {'c', 80, 75}};
    struct student* p;
    p = &s[0];  
    (p+1)->sum = (p+1)->kor + (p+2)->math;
    (p+1)->total = (p+1)->sum + p->kor + p->math;
    printf('%d\n', (p+1)->sum + (p+1)->total);
}
```

**overloading** - 메소드를 중복해서 작성

- 여러 개의 메소드를 중복 선언해서 사용하기 편리하게 하기 위한 게 목적

**overridding** - 상속 관계에서 재정의

- 부모 클래스의 정의에는 영향을 주지 않음
- 두 클래스 간 메소드명, 매개변수 개수, 자료형 모두 같아야 함

```java
class Person{
    String name = 'gildong';
    void sleep(){
        System.out.println('Sleep');
    }
}
class Student extends Person{
    void sleep(){
        System.out.println('Good Night');
    }
}
public class InheritanceEx{
    public static void main(String[] args){
        Student std = new Student();
        System.out.println(std.name);
        std.sleep();
    }
}
//gildong
//Good Night
```

**예외 처리** - C++, JAVA, Python

**PYTHON**

```python
emails = []
emails.append('pASs@har.or.kr')
emails.append('Dmok@or.kr')
emails.append('AcVS@market.or.kr')

id = list()
for email in emails:
    email = email.lower()
    id.append(email.split('@')[0])

print(id)
#[0]을 안하면
#[['pass', 'hard.or.kr'], ['dumok', 'abc.or.kr'], ['acvmar', 'market.or.kr']]

#[0]을 하면
#['pass', 'dumok', 'acvmar']
```

```python
```



---



## 운영체제 개요

**운영체제** - 시스템 소프트웨어의 일종

-  다른 프로그램들이 유용한 작업 할 수 있도록 환경 제공
- MS-DOS / WINDOWS XP / LINUX / UNIX / Mac OS / iOS / Android

- 목적
  - 처리 능력(Throughout) 
  - 응답 시간(Trnaround Time)
  - 신뢰성(Reliability) - 얼마나 오류없이 처리하는가
  - 사용 가능도(Availability)
- 일괄 처리 시스템 > 다중 프로그래밍 > 다중 모드 시스템 > 분산 처리 시스템

**시스템 소프트웨어** - 시스템 전체를 작동시키는 프로그램



## 주 메모리 관리



**기억장치** - 중앙처리장치가 작업 수행 위해 데이터나 프로그램을 일시적(또는 영구적)으로 저장하는 장치 / 보조기억장치는 주기억장치로 데이터 전송 / 레지스터는 데이터를 읽어들임

**기억장치 특징**

1. 주 메모리(주기억장치) - CPU가 직접 접근해서 처리ㅇ(ROM과 RAM으로 구성)
2. 캐시 메모리 - 주기억장치와 CPU의 속도 차이를 줄여서 효율 높이기 위해
3. 연관 메모리(CAM) - 저장된 내용을 이용해 접근하는 기억장치
4. 보조 메모리 - 부족한 용량 문제 해결 위해 외부 설치
5. 가상 메모리 - 보조기억장치를 주기억장치처럼 / 페이징 기법과 세그먼테이션 기법

**기억장치 관리 전략**

- 반입(Fetch)전략 - 시기 결정(요구 반입, 예상 반입)
- 배치(Placement)전략 - 위치 정함(최초 적합, 최적 적합, 최악 적합)
  - 단편화 - 기억장소들이 조각들로 나뉘어지는 현상
    - 내부 단편화 - 분할된 애가 할당 작업보다 커서 남는 조각 공간
    - 외부 단편화 - 분할된 애가 할당 작업보다 작아서 할당 불가능
    - 해결 방법 - 통합(인접한 애들끼리 모으기), 압축(서로 떨어져 있는 공백 모으기 / 가비키 컬렉션)
- 교체(Replacement)전략 - 제거할 아이 선택(FIFO, OPT, LRU, LFU, NUR, SCR)

**가상 메모리** - 가상기억장치의 주소를 주기억장치의 주소로 변환하는 주소변환 작업이 필요

1. 페이징 기법
   - 동일한 크기로 나눈 후 적재
   - 위치 정보를 가진 페이지 맵 테이블이 필요
   - 내부 단편화 발생할 수 ㅇ
   - 페이지 크기 클수록 > 맵 테이블 크기 작아지고 > 단편화 증가 > 디스크 접근 횟수 감소 > 전체 입출력 시간 감소
2. 세그먼테이션 기법
   - 다양한 크기의 논리적인 단위로 나눠서
     - 세그먼트 맵 테이블 필요
     - 외부 단편화 발생할 수 ㅇ

**매핑 테이블** - 논리적 주소와 물리적 주소를 연결하는 과정

**페이지 교체 알고리즘** - 주기억장치에 없는 페이지 부재시 가상기억장치의 페이지를 주기억장치에 적재해야

- OPT(optimal page replacement) - 이후에 가장 오랫동안 사용되지 않을
- FIFO(First in First out) - 가장 먼저 적재된 애를 먼저 교체 / 벨레이디의 모순 
- LRU(Least Recently Used) - 가장 오랫동안 사용되지 않았던 페이지 먼저 교체
- LFU(Least Frequently Used) - 참조된 횟수가 가장 적은 페이지 교체
- NUR(Not Used Recently) - 최근에 사용하지 않은 페이지 먼저 교체 / 두 개의 하드웨어 비트 필요
- SCR(Second Chance Replacement) - fifo 순으로 유지하면서 lru 근사 알고리즘처럼 참조 비트 가지게

**가상기억장치 관련 용어**

- 구역성(지역성) - 일부 페이지만 집중적으로 참조되는 경향 / 시간 구역성, 공간 구역성
- 워킹 셋 - 일정 시간 동안 자주 참조하는 페이지들의 집합
- 스래싱 - 페이지 교체에 소비되는 시간이 더 많이 드는 현상(cpu 이용률 증가, 워킹셋 방법 사용, 페이지 부재율 조절 후 대처)
- 페이지 부재 - 주기억장치에 없는 현상



## 프로세스 스케줄링

**프로세스** - 운영체제가 관리하는 실행 단위 / 실행 중인 프로그램 / PCB를 가진 프로그램

**PCB** - 프로세스 제어 블록 / 운영체제가 프로세스에 대한 중요 정보를 저장해 놓을 수 있는 저장 장소 / 각 프로세스는 고유의 PCB를 가짐 / 같이 생성되고 같이 제거됨

**프로세스 상태 전이** - Dispatch > Block > Wake Up

1. 준비 상태 - CPU를 할당받기 위해 기다리고 있는 상태
2. 실행 상태 - CPU 할당받아서 실행되는 상태 / CPU 스케줄러에 의해 수행
3. 대기 상태 - 입출력 처리 필요하면 대기 상태로 전이 / 끝나면 준비 상태로 전이

**스레드(Thread)** - 제어의 흐름 / 프로세스에서 실행의 개념만 분리 / 프로세스의 일부 특성을 가지고 있어서 경량 프로세스라고도 함 / 병행성 증가시키기 위한 메커니즘 / 소속된 프로세스의 자원들과 메모리 공유

**프로세스 스케줄링** - 생성 및 실행에 필요한 시스템의 자원을 해당 프로세스에 할당

- 목적 - 공정성 유지 / 단위 시간 당 처리량 최대화
- 비선점 기법 - 다른 프로세스가 CPU를 강제적으로 못뺏는 방식
  - 일괄 처리 시스템에 적합
  - FCFS - 준비상태 큐에 도착한 순서대로
  - SJF - 실행 시간이 가장 짧은 프로세스에게 먼저 할당
  - HRN - 서비스 받을 시간과 기다린 시간으로 결정 
    - (대기 시간 + 서비스 시간) / 서비스 시간
  - 기한부 - 특별한 시간이나 만료시간 안에 완료되도록
  - 우선순위 - 우선순위가 가장 높은 프로세스에게 먼저 할당 / 에이징 기법(무기한 문제 방지)
- 선점 기법 - 우선순위가 높은 다른 프로세스가 CPU를 강제적으로 뺏을 수 있는 방식
  - 대화식 시분할 시스템에 적합
  - SRT - 실행 중인 프로세스 남은 시간과 새로 도착한 애의 실행 시간 비교 > 실행 시간 더 짧은 애에게 / 시분할 시스템에 유용
  - RR - 시간 할당량 안에 마치지 않으면 리스트의 가장 뒤로 배치
    - 시간 할당량 너무 커지면 FCFS랑 비슷해지고, 할당량 너무 작아지면 오버헤드 커짐
  - 다단계 큐(MQ) - 우선순위에 따라 상위, 중위, 하위 단계의 단계별 준비 큐 배치
  - 다단계 피드백 큐(MFQ) - 시간 할당량 안에 완료하지 못한 애는 다음 단계 준비상태 큐로 이동 / 짧은 작업에게 우선권 부여 / 마지막 단계 큐에서는 라운드로빈(RR) 방식 

**문맥 교환** - 다중 프로그래밍 시스템에서 CPU가 할당되는 프로세스 변경하기 위해 실행 중인 상태 정보 저장하고, 앞으로 실행될 정보 설정한 다음 중앙처리장치 할당해서 실행되도록

**병행 프로세스** - 두 개 이상의 프로세스들이 동시에 실행 상태

- 독립적 병행 프로세스 / 병행 프로세스
- 임계 구역 : 여러 개 프로세스가 공유하는 자원이나 데이터에 대해 어느 한 시점에서 하나의 프로세스만 사용할 수 있도록 지정된 공유 자원
- 동기화 기법 : 두 개 이상 프로세스를 한 시점에 동시에 처리할 수 없기 때문에 처리 순서 결정 / 상호 배제의 한 형태
- 세마포어 : Dijkstra가 제안한 상호 배제 알고리즘 / 임계 구역에 대해 접근하기 위해 P와 V 연산 통해 동기 유지하고 상호 배제 원리 보장
- 모니터 : 필요한 데이터 및 프로시저를 포함하는 병행성 구조 / 한 순간에 하나의 프로세스만 모니터에 진입 가능

**교착 상태** - 상호 배제에 의해 나타나는 문제점 / 두 개 이상의 프로세스들이 자원 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원 요구 > 무한정 기다림

- 발생 조건
  - 상호 배제 - 한 번에 한 개의 프로세스만 사용할 수 있어야
  - 점유 및 대기 - 이미 자원 가진 애가 다른 자원 할당 요구
  - 비선점 - 사용 끝날 때까지 강제로 뺏을 수 없음
  - 환형 대기 - 이미 자원 가진 애가 앞이나 뒤의 자원 요구
- 해결 방법
  - 예방
  - 회피 - 은행원 알고리즘과 관계있음
  - 발견
  - 회복



## 운영체제의 종류 및 Shell Script

**운영체제 종류**

- Windows
  - MS에서 발표
  - GUI
  - 선점형 멀티태스킹
  - PnP 지원(원하는 하드웨어 시스템에 부착하면 자동 인식해서 동작)
  - Single User System
- MS-DOS
  - CUI
  - Single User - Single Tasking
  - 트리 구조 파일 시스템
- Unix
  - Bell연구소에서 개발
  - 이식성 높고 대화식 운영체제
  - C언어로
  - CLI인터페이스 강력
  - Multi tasking - Multi User
  - 구성
    - Kernel - 중심부 / 주기억장치에 적재된 후 상주 / 하드웨어 캡슐화
    - Shell - 명령어 해석기
    - Utility - 편의를 위한 프로그램 제공
  - 주요 명령어
    - fork - 프로세스 생성, 복제
    - getpid - 자신 프로세스 아이디 얻기
    - getppid
    - chdir(cd) - 디렉터리 위치 변경
    - cp(copy) - 파일 복사
    - mv(move) - 파일 이동
    - mm(del) - 파일 삭제
    - cat(type) - 파일 내용 화면에 표시
    - chmod(attrib) - 파일 사용 허가 지정
    - ls(dir) - 현재 디렉터리 내 파일 목록 확인
    - chown - 파일 소유자 변경
- Linux
  - UNIX와 호환 완벽
  - Multi tasking - Multi User
  - 파일 확장자 개념 x