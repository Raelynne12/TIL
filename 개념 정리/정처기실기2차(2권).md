## 소프트웨어 개발 보안 설계



**소프트웨어 개발 보안**

1. 도출(Elicitation)
2. 분석(Analysis)
3. 명세(Specification)
4. 확인(Vaildation)



**SDLC 보안 적용 사례**

- MS-SDL 
  - 마이크로소프트사에서 자체적으로 수립한 SDL 방법론
- Seven Touch Points
  - 소프트웨어 보안 모범 사례를 SDL에 통합
  - 공통 위험 요소 파악하고 이해
- CLASP
  - SDLC 초기 단계 보안 강화 목적
  - 정형화된 개발 보안 프로세스



**정보 보안 3대 요소**

- 기밀성(Confidentially)
- 무결성(Integrity) - 인가된 사용자가 인가된 방법으로만 수정
- 가용성(Availability)



**KISA** - 한국인터넷진흥원 / 개발 보안 정책 및 가이드 개발



## 암호화 알고리즘



**시큐어 코딩 가이드** 

- 7항목 - 입력 데이터 검증 및 표현 / 보안 기능 / 시간 및 상태 / 에러 처리 / 코드 오류 / 캡슐화 / API 오용



**암호화 알고리즘**

- 양방향
  - 대칭키(비밀키) - 키 분배가 공개키보다 어려움
    - 스트림 방식
      - 암호화 할 때 XOR 연산 사용
      - RC4 / SEAL ...
    - 블록 방식
      - 평문을 블록 단위로 암호화
      - DES -  IBM이 개발 / 전사공격에 취약
      - AES - DES 대신하는 표준 / SPN 구조
      - ARIA - 우리나라 개발 / 우리나라 표준
      - SEED - 국내 개발 / 국제 표준으로 지정
      - IDEA - 스위스에서 DES 대체하기 위해 개발 / 세 가지 연산 혼합
  - 비대칭키(공개키)
    - 복호화키 공개해도 ㅇ
    - RSA - 소인수분해 어려움 기초 / MIT에 의해 제안
    - EIGama - 이산대수 문제 기초 / 암호문의 길이가 2배로 늘어나는 특징
- 해시(HASH)
  - 고정된 길이의 출력값으로 변환
  - 의사 난수 생성 > 값 > 해시값
  - 디지털 서명에 이용 > 데이터 무결성 제공
  - SHA - 미국 NIST에 의해 개발 / 가장 많이 사용
  - MD5 - 충돌 회피성에서 문제점 발견
  - HAS-160 - 국내에서 개발 / SHA와 비슷



## 서비스 공격 유형



- DoS - 시스템 자원 부족하게 해서 원래 용도로 사용하지 못하게
  - 가용성 위협
  - 자신의 IP 주소를 속여서 다량으로 서버에 보냄
  - 스머프(Smurf) - 대량의 ICMP 응답 패킷 전송 > 서비스 거부 유발
  - TCP SYN flooding - TCP 연결 설정 과정의 취약점 악용
  - UDP 플러딩 - 대량의 UDP 패킷 만들어 보내서 정상적 서비스 못하게
  - Ping 플러딩 - Ping 테스트를 공격 대상 컴퓨터를 확인하려는 방법으로 사용
  - Ping of Death - 비정상적 ICMP 패킷 전송 > 성능 저하
  - 티어드랍 - 패킷 재조합 문제 악용 > 순서 조작된 조각들 보내서 자원 고갈
  - LAND Attack - IP 스푸핑 이용한 SYN 공격 / 출발지랑 목적지 주소 동일하게
- DDoS - 여러 대 공격자 분산 배치 > 동시에 서비스 거부 공격
  - 공격에 사용된 좀비 PC는 스스로 하드디스크 손상시킬 수 ㅇ
  - 좀비 PC끼리 형성된 네트워크 >> 봇넷
  - 공격용 도구 : Trinoo, TFN 등 
- 피싱 - 가짜 웹사이트를 통해서 개인정보 탈취
- 파밍 - DNS의 이름을 속여서 진짜 웹사이트로 오인하게
- 스니핑 - 도청(자기가 아닌 다른 사람들의 패킷 교환을 엿듣기)
- 스미싱 - 메시지를 통해 주소 클릭하면 악성코드 설치
- 큐싱 - QR코드를 통해 악성 앱 내려받도록
- 랜섬웨어
- 키로거
- SQL 삽입 - 악의적으로 만든 SQL 명령을 수행하도록
- XSS - 원본과 함께 악성코드 삽입 > 읽으면 실행
- 무작위 대입 공격 - 문자열 범위 정하고 생성 가능한 패스워드 활용
- 스피어 피싱 - 합법적 웹 사이트 미리 감염 > 방문하면 악성코드 설치
- APT - 장기간 접근을 위해 지속해서 수행되는 공격(지능적 지속 위협)
- 제로데이 - 알려지지 않은 취약점 및 악성 코드 등을 감염
- 백도어 - tripwire : 백도어 만들어 놓거나 파일 변경했을 때 분석하는 도구
- Rainbow Table Attack - 패스워드별로 해시값 미리 생성 > 반복 수행 > 일치하는 해시값으로 패스워드 탈취
- CSRF - 불특정 다수 대상으로 의지와 상관없이 의도에 따라 행동하게 만드는
- TOCTOU - 병렬 시스템 사용할 때 두 지점 사이 타이밍 노림



## 서버 인증



**사용자 인증 기법**

- 지식 기반 인증 - 아이디, 패스워드 같은
- 소유 기반 인증 - 인증 토큰 기반 / OTP, 스마트 카드 등
- 생체 기반 인증 



**서버 접근 통제** - 비인가자가 액세스하지 못하도록

- 접근 통제 요소 - 식별 / 인증 / 인가

- 강제적 접근 통제(MAC) - 중앙에서 보안 레벨 결정
  - 중앙 집중적 접근 통제 가능
  - 기밀성 매우 중요한 조직에서 사용
  - 다단계 보안 모델
  - Biba / Bell-Lapadula
- 임의적 접근 통제(DAC) - 정보 소유자가 보안 레벨 결정
  - 유연한 접근제어 서비스
- 역할 기반 접근 통제(RBAC) - 직책에 대한 권한 부여



## 보안 아키텍쳐



**보안 아키텍쳐** - 기밀성, 무결성, 가용성 높이기 위한

- 보안 프레임워크 - 기술적 보안, 관리적 보안, 물리적 보안 프레임워크로 나눠짐



**ISO 27001** - ISMS 요구사항 / 정보보호 관리체계에 대해 국제 인증 시 요구사항 정의



## 보안 솔루션



**방화벽** 

- 내부 네트워크와 외부 네트워크 사이에 위치
- 내부에서 외부로 나가는 패킷은 그대로 통과 > 방어하기 어려움
- 패킷 필터링 - 출발지, 목적지 IP 주소, 포트 번호 등 이용한 접속 제어 / OSI 3, 4계층에서 처리 > 속도 빠름
- 상태 검사 - 현재 연결 세션의 트래픽 상태와, 미리 저장된 상태와의 비교
- 응용 레벨 게이트웨이 - OSI 참조 모델 7계층  감시 > 안전한 데이터만 릴레이 > 속도 느림
- 회선 레벨 게이트웨이 - 두 개의 TCP 연결 설정 / 내부 IP 주소를 숨길 수 있음



**웹 방화벽**

- 클라이언트가 보낸 요청 검사 > 차단
- 사용자에게 실제 서버의 위치와 서버 정보를 숨기는 기능



**IDS 침입 탐지 시스템** - 외부 침입 탐지 목표 / 사후 조치 

- IDS 분류
  - HIDS - host based / 호스트 자원 일정 부분 점유
  - NIDS - network based / HIDS에 탐지하지 못한 침입 탐지
- 침입 탐지 기법
  - 오용 탐지 - 이미 발견돼서 알려진 공격 패턴과 일치하는지 
  - 이상 탐지 - 장기간 수집된 사용자 행동 패턴 / 알려지지 않은 공격에 굿



**IPS 침입 방지 시스템** - IDS와 방화벽 장점 결합 / 사전 조치

**DMZ 비무장 지대** - 보안 조치가 취해진 영역 / 웹서버, DNS서버, 메일 서버 등

**NAC 네트워크 접근 제어** - 접근하기 전에 보안 정책 준수 여부 검사해서 접근 통제

**DLP** - 기업 데이터 유출 방지 목표

**ESM 통합 보안 관리** - 보안 솔루션 하나로 모은 통합 보안 관리 시스템 / 각종 로그 통합 관리

**VPN 가상 사설망** - 안전하지 않은 공용 네트워크를 이용해서 사설 네트워크 구성 / 기밀성과 무결성 제공



## 취약점 분석 및 평가



**취약점 분석 기본 항목** 

- 기본 항목은 관리적, 물리적, 기술적 분야로 구분
- 상, 중, 하로 중요도 분리
  - 상은 필수로 점검
  - 중, 하는 기관의 사정에 따라 선택적으로 점검
- 절차
  1. 계획 수립
  2. 대상 선별
  3. 취약점 분석
  4. 취약점 수행



**로그 분석** 

- 데이터에 대한 기록이 파일, 인쇄물 형태로 저장
- 내부에서 영향 미치거나, 외부에서 시스템에 영향 미칠 때 > 데이터 기록해서 문제 해결이나 예방
- 로그 관리
  - 인증 Authentication - 사용자 신원 검증 제공
  - 인가 Authorization - 사용자에게 허용할 권한 제공
  - 계정 Accounting - 자원에 대한 정보 취합해서 제공
  - 로그는 중앙 시스템에 기록하거나, 분산 기록



---



## C

```c
#include <stdio.h>
int main()
{
	int month, day, birthday;
    int x, y;
    x = 5;
    y = 2;
    month = 1;
    day = 10;
    birthday = month == 8 && day == 19;
    print('birthday : %d', birthday);  //birthday : 0
    print('5>2 : %d', x>y);  //1
	return 0;
}
```

```c
#include <stdio.h>
int main()
{
    int Age;
    Age = 20;
    print('age : %d', Age); //20
    scanf('%d', &Age); 
    print('age : %d', Age); //25
    return 0;
}
```

```c
#include <stdio.h>
int main()
{
    int x, y, big;
    x = 5;
    y = 2;
    big = (x>y) ? x : y;
    print('큰 값 : %d\n', big); // 큰값 : 5
    return 0;
}
```

```c
#include <stdio.h>
int main()
{
    int i;
    int sum = 0;
    i = 1;
    do
    {
        sum += i;
        i++;
    }
    while(i <= 10);
    print('1~10 sum : %d', sum);
    return 0;
}
```

```c
#include <stdio.h>
int main()
{
    int i, j, sub_total;
    int s[3][2] = {{10,20},{30,40},{50,60}};
    for(i = 0; i < 3; i++){
        sub_total = 0;
        for(j = 0; j < 2; j++){
            sub_total += s[i][j];
        }
        print('%d 총점 : %d\n', i+1, sub_total);
    }
    return 0;
}
```



**비트 연산자**

- \>> << 시프트 연산자
  - \<< 왼쪽으로 이동
  - \<< 오른쪽으로 이동
- 논리 연산자
  - & : 논리곱(AND)
  - ^ : 배타적 논리합(XOR)
  - | : 논리합(OR)
  - ~ : 논리부정(NOT)



**연산자 우선순위**

1. 단항 연산자

   1. () [] - > .

   2. ! ~ ++ -- & * sizeof() cast

2. 이항 연산자

   1. \* / %
   2. \+ -
   3. << >>
   4. \> \>= \< \<=
   5. == != 
   6. &
   7. ^
   8. |
   9. &&
   10. ||

3. 삼항 연산자

   1. ? :

4. 대입 연산자

   1. = += *= &= 

5. 나열 연산자

   1. ,

## JAVA

```java
public class ArrayEx 
{
    public static void main(String[] args)
    {
        int[ ] intArr = {1, 2, 3};
        //int []intArr = {1,2,3};
        //int[] intArr = new int[3];
        for(int i = 0; i < intArr.length; i++)
            intArr[i] = i + 1;
        for(int i : intArr)
        {
            System.out.print(i + '');
        }
        System.out.println();
    }
} 
//1 2 3
```

```java
public class ArrayEx
{
    public static void main(String[] args)
    {
        String str1 = 'Semantic';
        String str2 = 'Error';
        String str3 = str1 + str2;
        System.out.println(str3); //SemanticError
    }
}
```

```java
public class ArrayEx
{
    public static void main(String[] args)
    {
        Scanner input = new Scanner(System.in);
        System.out.print('+ - choose : ');
        String sel = input.next();
        if(sel.equals('1'))
            System.out.println('10 + 20 = ' + (10+20));
        if(sel.equals('2'))
            System.out.println('10 - 20 = ' + (10-20));
    }
}
```



**연산자 우선순위**

1. 단항 연산자
   1. () []
   2. ! ~ ++ -- cast new
2. 이항 연산자
   1. \* / %
   2. \+ -
   3. \<< >> >>>
   4. \> \>= \< \<= instanceof
   5. == != 
   6. &
   7. ^
   8. |
   9. &&
   10. ||
3. 삼항 연산자
   1. ? :
4. 대입 연산자
   1. = += *= &=
5. 나열 연산자
   1. ,



**tree** - 포인터 변수 사용할 때 기억장소의 관리 문제로, 데이터 접근 경로가 없어진 후에도 메모리에 지속적으로 남아있어서(garbage), 이 쓰레기를 없애기 위해 사용되는 함수명



```c
#include <stdio.h>
int main()
{
    int num = 98;
    int *ptr;
    ptr = &num;
    num = num + 1;
    printf('%d/n', num);
    *ptr = *ptr + 1;
    print('%d', *ptr);
    return 0;
}
```

```c
#include <stdio.h>
struct student{
    char name[20];
    int kor, math, sum, total;
}
int main(){
    struct student s[3] = {{'a', 90, 85}, {'b', 100, 91}, {'c', 80, 75}};
    struct student* p;
    p = &s[0];  
    (p+1)->sum = (p+1)->kor + (p+2)->math;
    (p+1)->total = (p+1)->sum + p->kor + p->math;
    printf('%d\n', (p+1)->sum + (p+1)->total);
}
```

**overloading** - 메소드를 중복해서 작성

- 여러 개의 메소드를 중복 선언해서 사용하기 편리하게 하기 위한 게 목적

**overridding** - 상속 관계에서 재정의

- 부모 클래스의 정의에는 영향을 주지 않음
- 두 클래스 간 메소드명, 매개변수 개수, 자료형 모두 같아야 함

```java
class Person{
    String name = 'gildong';
    void sleep(){
        System.out.println('Sleep');
    }
}
class Student extends Person{
    void sleep(){
        System.out.println('Good Night');
    }
}
public class InheritanceEx{
    public static void main(String[] args){
        Student std = new Student();
        System.out.println(std.name);
        std.sleep();
    }
}
//gildong
//Good Night
```

**예외 처리** - C++, JAVA, Python

**PYTHON**

```python
emails = []
emails.append('pASs@har.or.kr')
emails.append('Dmok@or.kr')
emails.append('AcVS@market.or.kr')

id = list()
for email in emails:
    email = email.lower()
    id.append(email.split('@')[0])

print(id)
#[0]을 안하면
#[['pass', 'hard.or.kr'], ['dumok', 'abc.or.kr'], ['acvmar', 'market.or.kr']]

#[0]을 하면
#['pass', 'dumok', 'acvmar']
```

```python
```

