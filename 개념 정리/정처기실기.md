## 1. 요구사항 확인



#### 1. 소프트웨어 개발 방법론



SDLC : 소프트웨어 생명주기

- 시스템의 요구분석부터 유지보수까지 전 공정을 체계화
- 소프트웨어 생명주기 모델 프로세스
  1. 요구사항 분석
  2. 설계 
  3. 구현
  4. 테스트
     - 단위 테스트
     - 통합 테스트
     - 시스템 테스트
     - 인수 테스트
  5. 유지보수

- 모델 종류
  - 폭포수 모델
    - 모형의 적용 경험과 성공 사례 많음
  - 프로토타이핑 모델
    - 요구한 주요 기능을 프로토 타입으로 구현
    - 프로토타입은 구현 단계의 구현 골격
  - 나선형 모델
    - 계획 및 정의 > 위험 분석 > 개발 > 고객 평가
  - 반복적 모델
    - 구축대상을 나눠서 병렬적으로 개발 후 통합 or 반복적으로 개발해서 점차 완성



**소프트웨어 개발 방법론**

> 소프트웨어 개발 전 과정에 지속적으로 적용할 수 있는 방법, 절차, 기법
>
> sw를 하나의 생명체로 간주

- 종류
  - 구조적 방법론
    - 전체를 기능에 따라서 나눠서 개발 > 통합
    - 하향식 방법론
    - 구조적 프로그래밍 표현 위해 나씨-슈나이더만 차트 사용
  - 정보공학 방법론
    - 개발주기를 이용해서 대형 프로젝트 수행하는
  - 객체 지향 방법론
    - 사람이 이해하는 방식으로 시스템에 적용
    - 객체, 클래스, 메세지 사용
  - 컴포넌트기반 방법론
    - 컴포넌트를 조립해서 하나의 새로운 프로그램 작성
    - 개발기간 단축
    - 확장성(새로운 기능 추가 쉬움)
    - 소프트웨어 재사용 가능
  - 애자일 방법론
    - 사람이 중심 > 변화에 유연, 신속하게 적응
  - 제품 계열 방법론
    - 특정 제품에 적용하고 싶은 공통된 기능 정의해서 개발



**애자일**

- 등장 배경
  - sw 개발 환경 변화 : 모바일 환경으로 개발하는 트렌드, 시장 적시성과 잦은 배포의 중요성 부각
  - 기존 개발 방법론 한계 : 신속 대응 어려움

- 유형
  - XP
    - 1 ~ 3주의 반복 개발주기
    - 5개 가치와 12개의 실천항목
      - 가치
        1. 용기
        2. 단순성 : 필요한 것만 하고 그 이상의 것들은 x
        3. 의사소통
        4. 피드백
        5. 존중
      - 실천항목
        1. 짝 프로그래밍
        2. 공동 코드 소유 : 누구든지 언제로 수정 가능
        3. 지속적인 통합 : 매일 여러 번씩 sw 통합하고 빌드해야
        4. 계획 세우기
        5. 작은 릴리즈 : 작은 시스템 먼저 만들고 짧은 단위로 업데이트
        6. 메타포어 : 공통적인 이름 체계와 시스템 서술서로 의사소통 원활히
        7. 간단한 디자인
        8. 테스트 기반 개발 : 테스트 먼저 수행하고 이 테스트를 통과할 수 있도록 
        9. 리팩토링 : 기능 바꾸지 않으면서 중복제거, 단순화 등을 위해 시스템 재구성
        10. 40시간 작업 : 일주일에 40시간 이상 일하지 않아야 함
        11. 고객 상주 : 개발자들 질문에 즉각 대답해줄 수 있는 고객 
        12. 코드 표준 : 효과적 공동 작업 위해 코딩 표준 정의해야
  - 린(Lean)
    - 도요타의 린 시스템 품질기반을 적용 > 낭비 요소 제거해서 품질 향상
    - 7가지 원칙 : 낭비제거, 품질 내재화, 지식 창출, 늦은확정, 빠른 인도, 사람 존중, 전체 최적화
  - SCRUM
    - 매일 정해진 시간과 장소에서 짧은 시간의 개발을 하는 팀 위한 프로젝트 관리 중심
    - 백로그 : 제품과 프로젝트에 대한 요구사항
    - 스프린트 : 2 ~ 4주의 짧은 개발 기간으로 반복적 수행으로 개발 품질 향상
    - 스크럼 미팅 : 매일 15분 정도 미팅으로 to do list 계획 수립(데일리 미팅이라고도 함)
    - 스크럼 마스터 : 리더
    - 스프린트 회고 : 주기를 되돌아보며 규칙 준수 했는지, 개선점 등 생각 / 끝난 시점이나 일정 주기로 시행
    - 번 다운 차트 : 남아있는 백로그 대비 시간을 그래픽적으로 표현한 차트 / 보통 수직축에 위치



| 애자일            | 전통적                     |
| ----------------- | -------------------------- |
| 팀 중심           | 관리자 주도 개인 단위      |
| 문서화보다는 코드 | 문서화                     |
| 고객 가치 전달    | 계획, 일정 준수            |
| XP, 스크럼, 린    | 폭포수, 프로토타입, 나선형 |



**객체 지향 분석 방법론**

> 객체 지향 분석(OOA) : 요구사항 분석해서 모든 클래스(객체), 속성과 연산, 관계를 정해서 모델링

- 종류
  - OOSE
    - 야콥슨 
    - 유스케이스에 의한 접근 방법
  - OMT
    - 럼바우
    - 객체 > 동적 > 기능
    - 객체 : ER 다이어그램 만드는 과정까지 모델링 / 객체 다이어그램 활용
    - 동적 : 시간 흐름에 따라 / 상태 다이어그램 활용
    - 기능 : 자료 흐름 중심 / 자료 흐름도 활용
  - OOD
    - 부치
    - 문서화 강조해서 다이어그램 중심으로 개발
    - 분석과 설계 분리 불가능



**비용 산정 모형**

| 하향식 | 전문가에게             | 전문가 판단<br />델파이 기법                                 |
| ------ | ---------------------- | ------------------------------------------------------------ |
| 상향식 | 요구사항과 기능에 따라 | LoC(코드라인수)<br />Man Month<br />푸트남 모형<br />기능점수(FP) 모형 |

- LoC
  - 원시 코드 라인 수의 낙관치, 중간치, 비관치 측정
  - 측정 쉽고 이해하기 쉬워서 많이 사용
- Man Month
  - 한 사람이 1개월동안 할 수 있는 일의 양을 기준으로 비용 산정
- COCOMO
  - 보헴이 제안한 모형
  - 프로그램 규모에 따라 산정
  - 유연성 높아서 개발비 견적에 널리 통용
  - 조직형
    - 소규모
    - 5만 라인 이하
  - 반분리형
    - 30만 라인 이하
  - 임베디드형
    - 30만 라인 이상
- Putnam
  - 단계별로 요구할 인력 분포를 가정
  - 생명주기 예측 모형
- FP(기능점수)
  - 요구 기능을 증가시키는 인자별로 가중치 부여 > 가중치 합산해서 점수 계산 > 비용 산정



**일정 관리 모델**

- 주공정법(CPM)
  - 시작에서 종료까지 가장 긴 시간 걸리는 경로(임계 경로)
- PERT
  - 비관치, 중간치, 낙관치 3점 추정방식으로 일정 관리
- 중요 연쇄 프로젝트 관리(CCPM)



#### 2. 현행 시스템 분석



**현행 시스템 파악**

> 현행 시스템이 어떤 하위 시스템으로 구성되어 있고, 어떤 기술 요소를 사용하는지 등을 파악
>
> 즉 사용하고 있는 sw와 hw는 무엇인지, 네트워크 구성은 어떻게 되어 있는지 확인하는 활동

- 절차
  1. 구성/기능/인터페이스 파악
  2. 아키텍처 및 소프트웨어 구성 파악
  3. 하드웨어 및 네트워크 구성 파악



TCP/IP : 인터넷 프로토콜(IP)와 전송 조절 프로토콜(TCP)로 이루어짐

IP : 패킷 전달 여부를 보증하지 않고, 패킷을 보낸 순서와 받는 순서가 다를 수 있음

TCP : IP 위에서 동작하는 프로토콜, 데이터 전달 보증하고 보낸 순서대로 받게 해줌

X.25 : 패킷 교환망에서 회선 종단 장치와 데이터 단말 장치 사이에 이루어지는 상호 작용 규정한 프로토콜



**소프트웨어 아키텍처** - 여러가지 소프트웨어 구성요소와, 외부에 드러나는 특성, 관계 표현하는 구조체

- 소프트웨어 아키텍처 프레임워크 - 아키텍처가 표현해야 하는 내용 및 관계 제공하는 아키텍처 기술 표준
- 4+1뷰
  - 고객 요구사항 정리한 시나리오 4개 관점에서 바라보기
  - 유스케이스 : 요구사항 충족하는지, 서로 충돌하지 않는지 등 확인
  - 논리뷰(기능적), 구현뷰(정적), 프로세스 뷰(비기능적), 배포 뷰(어떻게 배치되는가)
- 소프트웨어 아키텍처 패턴 - sw 설계할 때 참조할 수 있는 해결 방식 / 재사용 가능, 일반화 / 특성을 개발 전 예측 가능
  - 계층화 패턴
    - 서로 마주보는 두 개 계층 사이에서만 상호 작용
  - 클라이언트-서버 패턴
    - 하나의 서버와 다수의 클라이언트, 서버는 계속 클라이언트로부터 요청 대기
  - 파이프-필터 패턴
    - 데이터 스트림 생성, 서브 시스템 이용해서 넘겨주고 처리하고 반복
  - 브로커 패턴
    - 분산 시스템에서 사용, 원격 서비스 실행해서 상호작용 가능
    - redirection
  - 모델-뷰-컨트롤러 패턴(MVC)
    - 대화형 애플리케이션을 세 개 서브 시스템으로 구조화
    - 대화형 어플리케이션에 좋
- 비용 평가 모델
  - SAAM - 경험이 없는 조직에서도 활용 가능
  - ATAM - 아키텍처 품질 속성 만족시키는지 판단, 상충관계 평가
  - CRAM - ATAM 바탕
  - ADR - 응집도 평가
  - ARID - 특정 부분에 대한 품질요소에 집중



**디자인 패턴**

- 유형
  - 목적	
    - 생성 : 생성에 관여
      - Builder : 과정과 표현하는 방법 분리 > 복잡한 객체 생성
      - Prototype : 처음부터 원형 만들어놓고 복사 후 > 필요한 부분만 수정
      - Factory Method : 상위에서 객체 생성하는 인터페이스 정의, 하위에서 수정
      - Abstract Factory : 구체적인 클래스에 의존x, 동일한 주제의 다른 팩토리 묶기
      - Singleton : 전역 변수 사용 안하고 객체 하나만 생성
    - 구조 : 클래스나 객체 조합
      - Bridge : 클래스 계층  연결하고, 구현부에서 추상 계층 분리
      - Decorator : 기존 구현된 거에 기능 추가해나가
      - Facade : 결합도 낮춰서 구조에 대한 파악 쉽게
      - Flyweight : 다수의 객체로 생성될 경우 본질 요소 클래스화, 가상 인스턴스 제공 > 메모리 절감
      - Proxy : 대리 객체로 정보은닉, 특정 객체로의 접근 제어
      - Composite : 부분-전체 계층 표현
      - Adapter  : 재사용할 수 있도록 중간에서 맞춰줌
    - 행위 : 상호작용 방법과 역할 분담
      - Mediator : 중재자
      - Interpreter : 언어의 다양한 해석, 구문 나누기
      - Iterator : 내부 구조 노출 안하고 순차적으로 접근 가능하게
      - Tempate Method : 일부분 서브 클래스로 캡슐화
      - Observer : 일대 다 의존성, 느슨하게 결합
      - State : 코드 수정 최소화, 유지보수 편의성
      - Visitor : 각 클래스 돌아다니며 특정 작업 수행
      - Command
      - Strategy : 행위 객체를 클래스로 캡슐화 > 동적으로 행위 자유롭게
      - Memento : 작업취소 요청 가능
      - Chain of Responsibility : 하드코딩 되어 있을  때, 다르게 처리될 수 있도록 연결
  - 범위
    - 클래스
    - 객체





#### 3. 요구사항 확인



**요구공학**

> 이해관계자 사이 효과적인 의사소통 수단 제공하고 개발의 요구사항에 대한 공통된 이해 설정



**요구사항 분류**

- 요구사항 : 파악의 기본은 시스템의 요구사항에 대한 파악

- 기능적
  - 시스템이 제공하는 기능, 서비스에 대한 요구사항
  - 특정 입력에 어떻게 반응해야 하는지, 어떻게 동작해야 하는지
  - 기능성, 완전성, 일관성
  - 장바구니 기능 제공하는 사례, 결제수단을 여러 가지로 주는 사례
- 비기능적
  - 시스템이 수행하는 기능 이외의 사항, 구축에 대한 제약사항에 관한 요구사항
  - 품질 속성에 관련해서 시스템이 갖춰야 할 사항
  - 시스템이 준수해야 할 제한 조건에 관한 기술
  - 신뢰성, 사용성, 효율성, 유지보수성, 이식성, 보안성 및 등등
  - 특정 함수 호출시간은 3초를 넘지 말아야, 시스템은 하루 24시간 가동돼야 하고 가동률 99.5%를 만족해야 등등의 사례



**요구공학 프로세스**

- 요구사항 개발 단계
  - 요구사항 도출, 분석, 명세, 확인 및 검증 단계
  - 도출(Elicitation) > 분석(Analysis) > 명세(Specification) > 확인(Validation)
- 요구사항 관리 단계





----



## 4과목 프로그래밍 언어 및 활용



**아스키코드**

|      | 0    | null  |      |      |      |
| ---- | ---- | ----- | ---- | ---- | ---- |
|      | 32   | space |      |      |      |
|      | 48   | 0     |      |      |      |
|      | 90   | a     |      |      |      |



**static 변수** - 시작에만 초기화



**데이터 타입**

- boolean - c언어 지원 안됨
- float - 4byte - 6자리
- double - 8byte - 15자리
- 파이썬은 별도 선언 x



**배열**

- c언어
  - 초기값 선언 안하면 >> 쓰레기값
- java
  - 초기값 선언 안하면 >> 정수는 0, 실수는 0.0, 문자열은 NULL



**포인터**

- 1차원 배열 > 배열명만 단독 >> 1차원 포인터
- 2차원 배열 > 배열명만 단독 >> 2차원 포인터

- int a\[3][2] = {};
  int *p = a[1];

  > a[] : 1차원 포인터
  >
  > a : 2차원 포인터 >> ** 이렇게 해야
  >
  > *(p+1) >> &a\[1][1]

- int a[4];

  > a = &a[0]
  >
  > a[0] = *a



**자료형**

- 자바
  - HashSet - 중복 없고, 순서 중요하지 않음
  - ArrayList - 크기 가변적, 순서 중요, 검색할 때 b
  - LinkedList - 데이터 삽입, 삭제할 때 b
  - HashMap - 키-값
- 파이썬
  - 세트형
  - 리스트형
  - 튜플형
  - 딕셔너리형



**식별자**

1) 변수사용 > 첫자리 숫자는 안됨
2) 표기법
   - 카멜 : inputFunction
   - 파스칼 : InputFunction
   - 스네이크 : input_function
   - 헝가리안 : nScore



**연산자 우선순위**

1. 단항 > 이항 > 삼항 > 대입

2. 증삼시 관비 논삼대

   - x++ - ++x - ! - ~ - >> - >= - == - & - && - 조건식 - +=

   - ~NOT > 마이너스하고 -1



**입력함수**

- 자바
  - 정수 : nextInt()
  - 실수 : nextFloat()
  - 문자열 : nextLine()
- 파이썬
  - eval() >> 입력받은 문자열 숫자로



switch는 파이썬 안됨



**사용자 정의 자료형**

- 열거체
  - enum
- 구조체 (자바, 파이썬 안됨)
  - struct



**사용자 정의 함수**

- void는 return 안됨



**매개변수**

- 전달인자 = 실 매개변수
- 매개변수 = 형식 매개변수
- 전달방법 : call by value, call by reference



**클래스(c언어 지원 안됨)**

- public
- protected : 같은 패키지 + 하위
- default : 자바에만 존재
- private : 같은 클래스 내



static 메소드 : 인스턴스 생성 안해도 가능



**자신 클래스**

- 자바
  - this.
- 파이썬
  - self.



클래스 일반변수로 선언 > 생성자 호출

종료되면 > 소멸자 호출

- 자바
  - public {}
  - public finalize(매개변수){}
- 파이썬
  - def \__init__ (self, ~):
  - def \__del__ (self):



**오버로딩**

- 파이썬은 지원 안됨



**오버라이딩**

- 하위에서 상위 메소드 재정의
- 선언말고 생성된 곳으로 가



super써서 상위변수나 메소드 접근 가능

- 자바
  - super.~()
- 파이썬
  - super().~()



**추상클래스**

- 자식에게 강제로 기능
- 자바
  - abstract class ~ {
    	abstract ~ ();
    }
- 파이썬
  - class ~ :
    	def`~(self):
    		pass (아무것도 안하면 pass써줘야)



**인터페이스**

- 추상메소드, 상수만 멤버로 가능
- interface A {
  }
  class B implements A{
  }



**프로그래밍 언어 유형 분류**

- 개발 편의성
  - 저급 언어 - 기계어, 어셈블리어
  - 고급 언어 - C, C++, JAVA, PYTHON
- 실행 방식
  - 명령형 언어 = 절차형 언어 - 순차적으로 실행
  - 객체 지향 언어 - 객체 간 메시지 통신 - JAVA, C++
  - 함수형 언어 - 수학적 수식 - LISP
  - 논리형 언어 - 논리 문장 - 프롤로그
- 구현 기법
  - 컴파일 방식 언어 - 고급 언어를 기계어로, 실행 속도 높음 - C, C++
  - 인터프리터 방식 언어 - 하나씩 번역하고 실행 - LISP
  - 혼합형 방식 언어 - JAVA



**프로그래밍 언어별 특성**

- 절차적

  - C - 유닉스 운영 체제, 모든 컴퓨터 시스템에서 사용할  수 있도록

  - 포트란 - 과학 기술 전문 언어

- 객체 지향
  - C++ - 메모리 관리 신경써야 
  - C# - 마이크로소프트에서 개발
  - JAVA - 웹 애플리케이션 개발에 가장 많이 사용
  - Delphi - 파스칼 문법에 여러 기능 추가, 윈도 아래에서 모든 부분 프로그래밍 가능
- 스크립트
  - PHP - 동적 웹페이지 만들기 위해, 자체 인터프리터 제공
  - Perl - 실용성 모토
  - Phython - 다양한 플랫폼, 라이브러리 풍부
  - Javascript - 객체 기반, 웹 브라우저 내에서 주로 사용
- 선언형
  - 함수형 - 하스켈, LISP
  - 논리형 - 프롤로그 - 논리식 기반 (계산 언어학, 자연언어 처리 분야)
  - 특수분야 - SQL - RDBMS 데이터 관리하기 위한



**객체 지향 프로그래밍**

- 구성요소
  1. 객체
     - 구성요소
       1. 개체 - 본질
       2. 속성 - 자료 저장소
       3. 메소드 - 호출 단위
  2. 클래스
  3. 메시지



**라이브러리**

- 구성
  - 도움말
  - 설치파일
  - 샘플코드
- 종류
  - 표준
    1. 문자열 라이브러리(string.h)
       1. strcat(a,b) : a뒤에 b글자 붙이기
       2. strcpy(a,b) : a랑 b 모두 b 됨
       3. strcmp(a,b) : 첫 글자 아스키 코드 값 계산해서 a가 적으면 음수로 출력
       4. strlen(a)
    2. 표준 라이브러리(stdlib.h)
       1. atoi(a) : 문자열을 정수형으로
       2. atof(a) : 문자열을 실수형으로
       3. itoa(a,b,c) : a를 문자로 변환해서 b에 c진수로
    3. 수학 라이브러리(math.h)
       1. ceil(a) : 소수점 올림
       2. floor(a) : 소수점 내림
  - 외부



**모듈과 패키지**

- 모듈 - 전역변수, 함수 등 모아둔 파일 - import 모듈명
- 패키지 - 모듈을 디렉토리 형식으로 구조화 - import 패키지명.모듈명
